!=======================================================================
! Generated by  : PSCAD v4.5.0.0
!
! Warning:  The content of this file is automatically generated.
!           Do not modify, as any changes made here will be lost!
!-----------------------------------------------------------------------
! Component     : Main
! Description   : 
!-----------------------------------------------------------------------


!=======================================================================

      SUBROUTINE MainDyn()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 'emtstor.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's2.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'fnames.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'matlab.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------

!     SUBR    DQDyn         ! 
      REAL    EMTDC_XPI     ! 'Proportional-Integral Controller /w Interpolation'
!     SUBR    EMTDC_X2COMP  ! 'Comparator with Interpolation'
!     SUBR    EMTDC_XTTRANS  ! 'Timed Transition'
!     SUBR    abcDyn        ! 
!     SUBR    3PHVSRC       ! 3-Phase Source model

!---------------------------------------
! Variable Declarations
!---------------------------------------


! Subroutine Arguments

! Electrical Node Indices

! Control Signals
      INTEGER  IT_1, BRK1, BRK
      REAL     RT_1, RT_2, RT_3, RT_4, gt1(2)
      REAL     gt4(2), gt3(2), gt6(2), gt5(2)
      REAL     gt2(2), Iap, Vin, RT_5, Iqref
      REAL     Pout, Iagf, Ud1, Uq1, RT_6, RT_7
      REAL     ki, kp, I, RT_8, RT_9, RT_10, Vap
      REAL     Vbp, Vcp, Icp, Ibp, Ud, Uq, theta
      REAL     Ic, Ea, Vc, GV, Icr, Iao, Iq, Id
      REAL     wl, P, Idc, dcVltg, RT_11, RT_12
      REAL     RT_13, RT_14, RT_15, RT_16, RT_17
      REAL     RT_18, RT_19, Igto1, Vgto1, I2(3)
      REAL     E2(3), Q, Vrms, Ibo, Ico

! Internal Variables
      INTEGER  IVD1_1, IVD1_2
      REAL     RVD1_1, RVD1_2, RVD1_3, RVD2_1(2)
      REAL     RVD2_2(2), RVD1_4

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER ISTOI, ISTOF, IT_0                  ! Storage Indices
      INTEGER ICX, IPGB                           ! Control/Monitoring
      INTEGER ISUBS, SS(1), IBRCH(1), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------

! Dsdyn <-> Dsout transfer index storage

      NTXFR = NTXFR + 1

      TXFR(NTXFR,1) = NSTOL
      TXFR(NTXFR,2) = NSTOI
      TXFR(NTXFR,3) = NSTOF
      TXFR(NTXFR,4) = NSTOC

! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      ISTOI     = NSTOI
      NSTOI     = NSTOI + 3
      ISTOF     = NSTOF
      NSTOF     = NSTOF + 73
      IPGB      = NPGB
      NPGB      = NPGB + 36
      ICX       = NCX
      NCX       = NCX + 3
      INODE     = NNODE + 2
      NNODE     = NNODE + 24

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 1

      DO IT_0 = 1,1
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 57
!---------------------------------------
! Transfers from storage arrays
!---------------------------------------

      RT_1     = STOF(ISTOF + 1)
      RT_2     = STOF(ISTOF + 2)
      RT_3     = STOF(ISTOF + 3)
      RT_4     = STOF(ISTOF + 4)
      Iap      = STOF(ISTOF + 17)
      Vin      = STOF(ISTOF + 18)
      RT_5     = STOF(ISTOF + 19)
      IT_1     = STOI(ISTOI + 1)
      BRK1     = STOI(ISTOI + 2)
      Iqref    = STOF(ISTOF + 20)
      Pout     = STOF(ISTOF + 21)
      BRK      = STOI(ISTOI + 3)
      Iagf     = STOF(ISTOF + 22)
      Ud1      = STOF(ISTOF + 23)
      Uq1      = STOF(ISTOF + 24)
      RT_6     = STOF(ISTOF + 25)
      RT_7     = STOF(ISTOF + 26)
      ki       = STOF(ISTOF + 27)
      kp       = STOF(ISTOF + 28)
      I        = STOF(ISTOF + 29)
      RT_8     = STOF(ISTOF + 30)
      RT_9     = STOF(ISTOF + 31)
      RT_10    = STOF(ISTOF + 32)
      Vap      = STOF(ISTOF + 33)
      Vbp      = STOF(ISTOF + 34)
      Vcp      = STOF(ISTOF + 35)
      Icp      = STOF(ISTOF + 36)
      Ibp      = STOF(ISTOF + 37)
      Ud       = STOF(ISTOF + 38)
      Uq       = STOF(ISTOF + 39)
      theta    = STOF(ISTOF + 40)
      Ic       = STOF(ISTOF + 41)
      Ea       = STOF(ISTOF + 42)
      Vc       = STOF(ISTOF + 43)
      GV       = STOF(ISTOF + 44)
      Icr      = STOF(ISTOF + 45)
      Iao      = STOF(ISTOF + 46)
      Iq       = STOF(ISTOF + 47)
      Id       = STOF(ISTOF + 48)
      wl       = STOF(ISTOF + 49)
      P        = STOF(ISTOF + 50)
      Idc      = STOF(ISTOF + 51)
      dcVltg   = STOF(ISTOF + 52)
      RT_11    = STOF(ISTOF + 53)
      RT_12    = STOF(ISTOF + 54)
      RT_13    = STOF(ISTOF + 55)
      RT_14    = STOF(ISTOF + 56)
      RT_15    = STOF(ISTOF + 57)
      RT_16    = STOF(ISTOF + 58)
      RT_17    = STOF(ISTOF + 59)
      RT_18    = STOF(ISTOF + 60)
      RT_19    = STOF(ISTOF + 61)
      Igto1    = STOF(ISTOF + 62)
      Vgto1    = STOF(ISTOF + 63)
      Q        = STOF(ISTOF + 70)
      Vrms     = STOF(ISTOF + 71)
      Ibo      = STOF(ISTOF + 72)
      Ico      = STOF(ISTOF + 73)

! Array (1:2) quantities...
      DO IT_0 = 1,2
         gt1(IT_0) = STOF(ISTOF + 4 + IT_0)
         gt4(IT_0) = STOF(ISTOF + 6 + IT_0)
         gt3(IT_0) = STOF(ISTOF + 8 + IT_0)
         gt6(IT_0) = STOF(ISTOF + 10 + IT_0)
         gt5(IT_0) = STOF(ISTOF + 12 + IT_0)
         gt2(IT_0) = STOF(ISTOF + 14 + IT_0)
      END DO

! Array (1:3) quantities...
      DO IT_0 = 1,3
         I2(IT_0) = STOF(ISTOF + 63 + IT_0)
         E2(IT_0) = STOF(ISTOF + 66 + IT_0)
      END DO

!---------------------------------------
! Electrical Node Lookup
!---------------------------------------


!---------------------------------------
! Configuration of Models
!---------------------------------------

      IF ( TIMEZERO ) THEN
         FILENAME = 'Main.dta'
         CALL EMTDC_OPENFILE
         SECTION = 'DATADSD:'
         CALL EMTDC_GOTOSECTION
      ENDIF
!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 160:[tbreakn] Timed Breaker Logic 
! Timed breaker logic
      IF ( TIMEZERO ) THEN
         BRK = 0
      ELSE
         BRK = 0
         IF ( TIME .GE. 0.3 ) BRK = (1-0)
      ENDIF

! 190:[const] Real Constant 
      RT_12 = 1.002

! 200:[time-sig] Output of Simulation Time 
      RT_11 = TIME

! 280:[tbreakn] Timed Breaker Logic 
! Timed breaker logic
      IF ( TIMEZERO ) THEN
         BRK1 = 1
      ELSE
         BRK1 = 1
         IF ( TIME .GE. 0.99 ) BRK1 = (1-1)
      ENDIF

! 310:[var] Variable Input Slider 'ref'
      RT_17 = CX(CXMAP(ICX+1))

! 330:[sumjct] Summing/Differencing Junctions 
      RT_16 = - RT_17 + dcVltg

! 340:[pgb] Output Channel 'BRK1'

      PGB(IPGB+9) = REAL(BRK1)

! 370:[DQ]  
      CALL DQDyn(Iap, Ibp, Icp, theta, Id, Iq)


! 380:[const] Real Constant 
      Iqref = 0.0

! 390:[sumjct] Summing/Differencing Junctions 
      RT_7 = + Iqref - Iq

! 400:[pgb] Output Channel 'Iq'

      PGB(IPGB+12) = Iq

! 410:[pi_ctlr] PI Controller \w Interpolation 
      RVD1_1 = RTCF(NRTCF)
      NRTCF = NRTCF + 1
      RVD2_1(1) = RT_7
      RVD2_1(2) = 0.0
      RT_15 = EMTDC_XPI(0,15.0,0.001,-1.5,1.5,RVD1_1,RVD2_1)

! 420:[const] Real Constant 
      RT_13 = 1.0

! 440:[pgb] Output Channel 'iqref'

      PGB(IPGB+14) = Iqref

! 450:[var] Variable Input Slider 'kp'
      kp = CX(CXMAP(ICX+2))

! 460:[signalgen] Signal Generator /w Interpolation 
      CALL COMPONENT_ID(ICALL_NO,802605095)
      CALL E_XSGEN1_EXE(1,20000.0,RVD2_1)
      RT_2 = RVD2_1(1)

! 470:[emtconst] Commonly Used Constants (pi...) 
      RT_18 = PI_

! 480:[gain] Gain Block 
!  Gain
      RT_19 = 100.0 * RT_18

! 490:[gain] Gain Block 
!  Gain
      wl = 0.0008 * RT_19

! 500:[var] Variable Input Slider 'I'
      I = CX(CXMAP(ICX+3))

! 520:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(0,0,RT_12,RT_11,0.0,0.0,1.0,RVD2_1)
      RT_5 = RVD2_1(1)

! 530:[DQ]  
      CALL DQDyn(Vap, Vbp, Vcp, theta, Ud, Uq)


! 540:[bin_delay] Timed ON/OFF Logic Transition 
!
      RVD2_1(1) = NINT(RT_5)
      RVD2_1(2) = 0.0
!
      CALL EMTDC_XTTRANS(0,0.002,0.0,RVD2_1,RVD2_2)
!
      IT_1 = RVD2_2(1)

! 550:[mult] Multiplier 
      RT_9 = Iq * wl

! 560:[div] Divider 
!
      IF (ABS(I) .LT. 1.0E-10) THEN
         IF (I .LT. 0.0)  THEN
            ki = -1.0E10 * RT_13
         ELSE
            ki =  1.0E10 * RT_13
         ENDIF
      ELSE
         ki = RT_13 / I
      ENDIF
!

! 570:[mult] Multiplier 
      RT_10 = Id * wl

! 580:[pi_ctlr] PI Controller \w Interpolation 
      RVD1_1 = RTCF(NRTCF)
      NRTCF = NRTCF + 1
      RVD2_1(1) = RT_16
      RVD2_1(2) = 0.0
      RT_8 = EMTDC_XPI(0,kp,ki,-0.5,0.5,RVD1_1,RVD2_1)

! 590:[sumjct] Summing/Differencing Junctions 
      RT_6 = + RT_8 - Id

! 600:[pi_ctlr] PI Controller \w Interpolation 
      RVD1_1 = RTCF(NRTCF)
      NRTCF = NRTCF + 1
      RVD2_1(1) = RT_6
      RVD2_1(2) = 0.0
      RT_14 = EMTDC_XPI(0,15.0,0.001,-1.5,1.5,RVD1_1,RVD2_1)

! 610:[sumjct] Summing/Differencing Junctions 
      Ud1 = + RT_14 - RT_9

! 620:[sumjct] Summing/Differencing Junctions 
      Uq1 = + RT_15 + RT_10

! 630:[abc]  
      CALL abcDyn(Ud1, Uq1, theta, RT_1, RT_3, RT_4)


! 640:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(1,0,RT_4,RT_2,1.0,0.0,0.0,gt5)

! 650:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(1,0,RT_3,RT_2,1.0,0.0,0.0,gt3)

! 660:[compar] Two Input Comparator 
!
      CALL EMTDC_X2COMP(1,0,RT_1,RT_2,1.0,0.0,0.0,gt1)

! 670:[sumjct] Summing/Differencing Junctions 
      GV = + RT_5 - REAL(IT_1)

! 680:[inv] Interpolated Logic Inverter 
      IF (NINT(gt5(1)) .NE. 0) THEN
         gt2(1) = 0.0
      ELSE
         gt2(1) = 1.0
      ENDIF
      gt2(2) = gt5(2)

! 690:[inv] Interpolated Logic Inverter 
      IF (NINT(gt3(1)) .NE. 0) THEN
         gt6(1) = 0.0
      ELSE
         gt6(1) = 1.0
      ENDIF
      gt6(2) = gt3(2)

! 700:[inv] Interpolated Logic Inverter 
      IF (NINT(gt1(1)) .NE. 0) THEN
         gt4(1) = 0.0
      ELSE
         gt4(1) = 1.0
      ENDIF
      gt4(2) = gt1(2)

! 710:[pgb] Output Channel 'pulse3'

      DO IVD1_1 = 1, 2
         PGB(IPGB+15+IVD1_1-1) = gt5(IVD1_1)
      ENDDO

! 720:[pgb] Output Channel 'Uq1'

      PGB(IPGB+17) = Uq1

! 730:[pgb] Output Channel 'pulse2'

      DO IVD1_1 = 1, 2
         PGB(IPGB+18+IVD1_1-1) = gt3(IVD1_1)
      ENDDO

! 740:[pgb] Output Channel 'Id'

      PGB(IPGB+20) = Id

! 750:[pgb] Output Channel 'triangle'

      PGB(IPGB+21) = RT_2

! 760:[pgb] Output Channel 'pulse1'

      DO IVD1_1 = 1, 2
         PGB(IPGB+22+IVD1_1-1) = gt1(IVD1_1)
      ENDDO

! 770:[pgb] Output Channel 'Ud1'

      PGB(IPGB+24) = Ud1

! 780:[pgb] Output Channel 'ref'

      PGB(IPGB+25) = RT_8

! 790:[pgb] Output Channel 'Uq'

      PGB(IPGB+26) = Uq

! 800:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Thyristor
      CALL COMPONENT_ID(ICALL_NO,1368230651)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+44), NINT(GV), 0.0)

! 810:[pgb] Output Channel 'Ud'

      PGB(IPGB+27) = Ud

! 820:[pgb] Output Channel 'GV'

      PGB(IPGB+28) = GV

! 830:[breaker1] Single Phase Breaker 'BRK1'
      IVD1_2 = NSTORI
      NSTORI = NSTORI + 1
      CALL E1PBRKR1_EXE(SS(1), (IBRCH(1)+43),0.005,1000000.0,0,NINT(1.0-&
     &REAL(BRK1)))
      IVD1_1 = 2*E_BtoI(OPENBR( (IBRCH(1)+43),SS(1)))
      IF (FIRSTSTEP .OR. (STORI(IVD1_2) .NE. IVD1_1)) THEN
         CALL PSCAD_AGI(307025180,IVD1_1,"BOpen")
      ENDIF
      STORI(IVD1_2) = 2*E_BtoI(OPENBR( (IBRCH(1)+43),SS(1)))

! 840:[peswitch] Power electronic switch 
! Power Electronic Switch Model: IGBT
      CALL COMPONENT_ID(ICALL_NO,1464954777)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+11), NINT(gt4(1)), gt4(2))

! 850:[peswitch] Power electronic switch 
! Power Electronic Switch Model: IGBT
      CALL COMPONENT_ID(ICALL_NO,165197472)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+9), NINT(gt6(1)), gt6(2))

! 860:[peswitch] Power electronic switch 
! Power Electronic Switch Model: IGBT
      CALL COMPONENT_ID(ICALL_NO,509368295)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+7), NINT(gt2(1)), gt2(2))

! 880:[peswitch] Power electronic switch 
! Power Electronic Switch Model: IGBT
      CALL COMPONENT_ID(ICALL_NO,1996254875)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+1), NINT(gt1(1)), gt1(2))

! 900:[peswitch] Power electronic switch 
! Power Electronic Switch Model: IGBT
      CALL COMPONENT_ID(ICALL_NO,1358490044)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+3), NINT(gt3(1)), gt3(2))

! 910:[peswitch] Power electronic switch 
! Power Electronic Switch Model: IGBT
      CALL COMPONENT_ID(ICALL_NO,26346905)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+5), NINT(gt5(1)), gt5(2))

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,1044293893)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+17), 1, 0.0)

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,626869290)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+15), 1, 0.0)

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,1823210700)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+13), 1, 0.0)

! 1:[source_1] Single Phase Voltage Source Model 2 'Source1'
!  DC source: Type: R
      RVD1_1 = RTCF(NRTCF)
      RVD1_2 = RTCF(NRTCF+1)
      RVD1_3 = RTCF(NRTCF+2)
      RVD1_4 = RTCF(NRTCF+3)
      NRTCF = NRTCF + 4
      CALL EMTDC_1PVSRC(SS(1), (IBRCH(1)+38),RVD1_4,0,RVD1_1,RVD1_2,RVD1&
     &_3)

! 1:[source_3] Three Phase Voltage Source Model 2 'Source 2'
! Three Phase Source: Source 2  Type: Ideal
!  
      RVD1_1 = RTCF(NRTCF)
      RVD1_2 = RTCF(NRTCF+1)
      RVD1_3  = 0.0*PI_BY180
      RVD1_4 = RTCF(NRTCF+3)
      NRTCF  = NRTCF + 4
      CALL EMTDC_3PHVSRC(SS(1), (IBRCH(1)+28), (IBRCH(1)+29), (IBRCH(1)+&
     &30), RVD1_4, .TRUE., RVD1_1 , RVD1_2, RVD1_3)
!

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,190676001)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+19), 1, 0.0)

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,957739663)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+21), 1, 0.0)

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,1256651331)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+23), 1, 0.0)

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,1160824162)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+40), 1, 0.0)

! 1:[peswitch] Power electronic switch 
! Power Electronic Switch Model: Diode
      CALL COMPONENT_ID(ICALL_NO,1873259632)
      CALL PESWITCH1_EXE(SS(1), (IBRCH(1)+36), 1, 0.0)

!---------------------------------------
! Feedbacks and transfers to storage
!---------------------------------------

      STOF(ISTOF + 1) = RT_1
      STOF(ISTOF + 2) = RT_2
      STOF(ISTOF + 3) = RT_3
      STOF(ISTOF + 4) = RT_4
      STOF(ISTOF + 17) = Iap
      STOF(ISTOF + 18) = Vin
      STOF(ISTOF + 19) = RT_5
      STOI(ISTOI + 1) = IT_1
      STOI(ISTOI + 2) = BRK1
      STOF(ISTOF + 20) = Iqref
      STOF(ISTOF + 21) = Pout
      STOI(ISTOI + 3) = BRK
      STOF(ISTOF + 22) = Iagf
      STOF(ISTOF + 23) = Ud1
      STOF(ISTOF + 24) = Uq1
      STOF(ISTOF + 25) = RT_6
      STOF(ISTOF + 26) = RT_7
      STOF(ISTOF + 27) = ki
      STOF(ISTOF + 28) = kp
      STOF(ISTOF + 29) = I
      STOF(ISTOF + 30) = RT_8
      STOF(ISTOF + 31) = RT_9
      STOF(ISTOF + 32) = RT_10
      STOF(ISTOF + 33) = Vap
      STOF(ISTOF + 34) = Vbp
      STOF(ISTOF + 35) = Vcp
      STOF(ISTOF + 36) = Icp
      STOF(ISTOF + 37) = Ibp
      STOF(ISTOF + 38) = Ud
      STOF(ISTOF + 39) = Uq
      STOF(ISTOF + 40) = theta
      STOF(ISTOF + 41) = Ic
      STOF(ISTOF + 42) = Ea
      STOF(ISTOF + 43) = Vc
      STOF(ISTOF + 44) = GV
      STOF(ISTOF + 45) = Icr
      STOF(ISTOF + 46) = Iao
      STOF(ISTOF + 47) = Iq
      STOF(ISTOF + 48) = Id
      STOF(ISTOF + 49) = wl
      STOF(ISTOF + 50) = P
      STOF(ISTOF + 51) = Idc
      STOF(ISTOF + 52) = dcVltg
      STOF(ISTOF + 53) = RT_11
      STOF(ISTOF + 54) = RT_12
      STOF(ISTOF + 55) = RT_13
      STOF(ISTOF + 56) = RT_14
      STOF(ISTOF + 57) = RT_15
      STOF(ISTOF + 58) = RT_16
      STOF(ISTOF + 59) = RT_17
      STOF(ISTOF + 60) = RT_18
      STOF(ISTOF + 61) = RT_19
      STOF(ISTOF + 62) = Igto1
      STOF(ISTOF + 63) = Vgto1
      STOF(ISTOF + 70) = Q
      STOF(ISTOF + 71) = Vrms
      STOF(ISTOF + 72) = Ibo
      STOF(ISTOF + 73) = Ico

! Array (1:2) quantities...
      DO IT_0 = 1,2
         STOF(ISTOF + 4 + IT_0) = gt1(IT_0)
         STOF(ISTOF + 6 + IT_0) = gt4(IT_0)
         STOF(ISTOF + 8 + IT_0) = gt3(IT_0)
         STOF(ISTOF + 10 + IT_0) = gt6(IT_0)
         STOF(ISTOF + 12 + IT_0) = gt5(IT_0)
         STOF(ISTOF + 14 + IT_0) = gt2(IT_0)
      END DO

! Array (1:3) quantities...
      DO IT_0 = 1,3
         STOF(ISTOF + 63 + IT_0) = I2(IT_0)
         STOF(ISTOF + 66 + IT_0) = E2(IT_0)
      END DO

!---------------------------------------
! Transfer to Exports
!---------------------------------------

!---------------------------------------
! Close Model Data read
!---------------------------------------

      IF ( TIMEZERO ) CALL EMTDC_CLOSEFILE
      RETURN
      END

!=======================================================================

      SUBROUTINE MainOut()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 'emtstor.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's2.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'fnames.h'
      INCLUDE 'radiolinks.h'
      INCLUDE 'matlab.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------

      REAL    EMTDC_VVDC    ! 
      REAL    P3PH3         ! 
      REAL    Q3PH3         ! 
!     SUBR    DGTL_RMS3     ! '3 Phase Digital RMS Meter'
!     SUBR    DQOut         ! 
!     SUBR    abcOut        ! 
      REAL    VBRANCH       ! Voltage across the branch

!---------------------------------------
! Variable Declarations
!---------------------------------------


! Electrical Node Indices
      INTEGER  NT_2, NT_3, NT_5(3), NT_8, NT_12
      INTEGER  NT_13, NT_28

! Control Signals
      REAL     Iap, Vin, Pout, Iagf, Vap, Vbp
      REAL     Vcp, Icp, Ibp, theta, Ic, Ea, Vc
      REAL     Icr, Iao, P, Idc, dcVltg, Igto1
      REAL     Vgto1, I2(3), E2(3), Q, Vrms, Ibo
      REAL     Ico

! Internal Variables
      INTEGER  IVD1_1
      REAL     RVD1_1, RVD1_2, RVD1_3

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER ISTOL, ISTOI, ISTOF, ISTOC, IT_0    ! Storage Indices
      INTEGER IPGB                                ! Control/Monitoring
      INTEGER ISUBS, SS(1), IBRCH(1), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------

! Dsdyn <-> Dsout transfer index storage

      NTXFR = NTXFR + 1

      ISTOL = TXFR(NTXFR,1)
      ISTOI = TXFR(NTXFR,2)
      ISTOF = TXFR(NTXFR,3)
      ISTOC = TXFR(NTXFR,4)

! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      IPGB      = NPGB
      NPGB      = NPGB + 36
      NCX       = NCX + 0
      INODE     = NNODE + 2
      NNODE     = NNODE + 24

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 1

      DO IT_0 = 1,1
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 57
!---------------------------------------
! Transfers from storage arrays
!---------------------------------------

      Iap      = STOF(ISTOF + 17)
      Vin      = STOF(ISTOF + 18)
      Pout     = STOF(ISTOF + 21)
      Iagf     = STOF(ISTOF + 22)
      Vap      = STOF(ISTOF + 33)
      Vbp      = STOF(ISTOF + 34)
      Vcp      = STOF(ISTOF + 35)
      Icp      = STOF(ISTOF + 36)
      Ibp      = STOF(ISTOF + 37)
      theta    = STOF(ISTOF + 40)
      Ic       = STOF(ISTOF + 41)
      Ea       = STOF(ISTOF + 42)
      Vc       = STOF(ISTOF + 43)
      Icr      = STOF(ISTOF + 45)
      Iao      = STOF(ISTOF + 46)
      P        = STOF(ISTOF + 50)
      Idc      = STOF(ISTOF + 51)
      dcVltg   = STOF(ISTOF + 52)
      Igto1    = STOF(ISTOF + 62)
      Vgto1    = STOF(ISTOF + 63)
      Q        = STOF(ISTOF + 70)
      Vrms     = STOF(ISTOF + 71)
      Ibo      = STOF(ISTOF + 72)
      Ico      = STOF(ISTOF + 73)

! Array (1:3) quantities...
      DO IT_0 = 1,3
         I2(IT_0) = STOF(ISTOF + 63 + IT_0)
         E2(IT_0) = STOF(ISTOF + 66 + IT_0)
      END DO

!---------------------------------------
! Electrical Node Lookup
!---------------------------------------

      NT_2  = NODE(INODE + 2)
      NT_3  = NODE(INODE + 3)
      NT_8  = NODE(INODE + 10)
      NT_12 = NODE(INODE + 15)
      NT_13 = NODE(INODE + 16)
      NT_28 = NODE(INODE + 14)

! Array (1:3) quantities...
      DO IT_0 = 1,3
         NT_5(IT_0) = NODE(INODE + 4 + IT_0)
      END DO

!---------------------------------------
! Configuration of Models
!---------------------------------------

      IF ( TIMEZERO ) THEN
         FILENAME = 'Main.dta'
         CALL EMTDC_OPENFILE
         SECTION = 'DATADSO:'
         CALL EMTDC_GOTOSECTION
      ENDIF
!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 10:[voltmeter] Voltmeter (Line - Line) 'dcVltg'
      dcVltg = EMTDC_VVDC(SS(1), NT_3, NT_2)

! 20:[ammeter] Current Meter 'Idc'
      Idc = ( CBR((IBRCH(1)+34), SS(1)))

! 30:[ammeter] Current Meter 'Iap'
      Iap = ( CBR((IBRCH(1)+25), SS(1)))

! 40:[ammeter] Current Meter 'Iao'
      Iao = ( CBR((IBRCH(1)+46), SS(1)))

! 50:[ammeter] Current Meter 'Ibp'
      Ibp = ( CBR((IBRCH(1)+26), SS(1)))

! 60:[ammeter] Current Meter 'Icp'
      Icp = ( CBR((IBRCH(1)+27), SS(1)))

! 70:[voltmeter] Voltmeter (Line - Line) 'Vin'
      Vin = EMTDC_VVDC(SS(1), NT_28, 0)

! 80:[ammeter] Current Meter 'Ibo'
      Ibo = ( CBR((IBRCH(1)+47), SS(1)))

! 90:[ammeter] Current Meter 'Icr'
      Icr = ( CBR((IBRCH(1)+48), SS(1)))

! 100:[multimeter] Multimeter 
      IVD1_1 = NRTCF
      NRTCF  = NRTCF + 4
      I2(1) = ( CBR((IBRCH(1)+31), SS(1)))
      I2(2) = ( CBR((IBRCH(1)+32), SS(1)))
      I2(3) = ( CBR((IBRCH(1)+33), SS(1)))
      E2(1) = EMTDC_VVDC(SS(1), NT_5(1), 0)
      E2(2) = EMTDC_VVDC(SS(1), NT_5(2), 0)
      E2(3) = EMTDC_VVDC(SS(1), NT_5(3), 0)
      RVD1_1 = RTCF(IVD1_1) * P3PH3(SS(1), (IBRCH(1)+31), (IBRCH(1)+32),&
     & (IBRCH(1)+33),RTCF(IVD1_1+2),0)
      P = RVD1_1
      RVD1_1 = RTCF(IVD1_1) * Q3PH3(SS(1), (IBRCH(1)+31), (IBRCH(1)+32),&
     & (IBRCH(1)+33),RTCF(IVD1_1+2),0)
      Q = RVD1_1
      CALL DGTL_RMS3(256,SS(1),NT_5(1),NT_5(2),NT_5(3),RTCF(IVD1_1+3),1.&
     &0,0.0,RVD1_1)
      RVD1_1 = RTCF(IVD1_1+1)*RVD1_1
      Vrms = RVD1_1

! 110:[ammeter] Current Meter 'Iagf'
      Iagf = ( CBR((IBRCH(1)+35), SS(1)))

! 120:[ammeter] Current Meter 'Ico'
      Ico = ( CBR((IBRCH(1)+42), SS(1)))

! 130:[voltmeter] Voltmeter (Line - Line) 'Vap'
      Vap = EMTDC_VVDC(SS(1), NT_28, 0)

! 140:[voltmeter] Voltmeter (Line - Line) 'Vbp'
      Vbp = EMTDC_VVDC(SS(1), NT_12, 0)

! 150:[voltmeter] Voltmeter (Line - Line) 'Vcp'
      Vcp = EMTDC_VVDC(SS(1), NT_13, 0)

! 170:[pgb] Output Channel 'Vin'

      PGB(IPGB+1) = Vin

! 180:[pgb] Output Channel 'Vin'

      PGB(IPGB+2) = Vin

! 210:[voltmeter] Voltmeter (Line - Line) 'Ea'
      Ea = EMTDC_VVDC(SS(1), NT_28, NT_8)

! 220:[voltmetergnd] Voltmeter (Line - Ground) 'Vc'
      Vc = EMTDC_VVDC(SS(1), NT_8, 0)

! 230:[ammeter] Current Meter 'Ic'
      Ic = (-CBR((IBRCH(1)+39), SS(1)))

! 240:[pgb] Output Channel 'Ea'

      PGB(IPGB+3) = Ea

! 250:[pgb] Output Channel 'Ic'

      PGB(IPGB+4) = Ic

! 260:[pgb] Output Channel 'Vc'

      PGB(IPGB+5) = Vc

! 270:[pgb] Output Channel 'Vap'

      PGB(IPGB+6) = Vap

! 290:[pgb] Output Channel 'Vbp'

      PGB(IPGB+7) = Vbp

! 300:[tvekta] Phase-Locked Loop 
      RVD1_1 = 1.57
      CALL COMPONENT_ID(ICALL_NO,1655348963)
      CALL TVEKA1_EXE(Vap,Vbp,Vcp,50.0,900.0,RVD1_1,0.05,1.2,0.8,theta,R&
     &VD1_3,RVD1_2)
!

! 320:[pgb] Output Channel 'theta'

      PGB(IPGB+8) = theta

! 350:[pgb] Output Channel 'Vcp'

      PGB(IPGB+10) = Vcp

! 360:[pgb] Output Channel 'Iap'

      PGB(IPGB+11) = Iap

! 370:[DQ]  
      CALL DQOut()


! 430:[pgb] Output Channel 'P'

      PGB(IPGB+13) = P

! 510:[mult] Multiplier 
      Pout = dcVltg * Idc

! 530:[DQ]  
      CALL DQOut()


! 630:[abc]  
      CALL abcOut()


! 830:[breaker1] Single Phase Breaker 'BRK1'
! Single phase breaker current
!

! 870:[pgb] Output Channel 'Icr'

      PGB(IPGB+29) = Icr

! 880:[peswitch] Power electronic switch 
      Igto1 = ( CBR((IBRCH(1)+1), SS(1)))
      Vgto1 = VBRANCH(SS(1), (IBRCH(1)+1))

! 890:[pgb] Output Channel 'Vap'

      PGB(IPGB+30) = Vap

! 920:[pgb] Output Channel 'Iagf'

      PGB(IPGB+31) = Iagf

! 930:[pgb] Output Channel 'Iap'

      PGB(IPGB+32) = Iap

! 940:[pgb] Output Channel 'Iao'

      PGB(IPGB+33) = Iao

! 950:[pgb] Output Channel 'Idc'

      PGB(IPGB+34) = Idc

! 960:[pgb] Output Channel 'Pout'

      PGB(IPGB+35) = Pout

! 970:[pgb] Output Channel 'dcVltg'

      PGB(IPGB+36) = dcVltg

!---------------------------------------
! Feedbacks and transfers to storage
!---------------------------------------

      STOF(ISTOF + 17) = Iap
      STOF(ISTOF + 18) = Vin
      STOF(ISTOF + 21) = Pout
      STOF(ISTOF + 22) = Iagf
      STOF(ISTOF + 33) = Vap
      STOF(ISTOF + 34) = Vbp
      STOF(ISTOF + 35) = Vcp
      STOF(ISTOF + 36) = Icp
      STOF(ISTOF + 37) = Ibp
      STOF(ISTOF + 40) = theta
      STOF(ISTOF + 41) = Ic
      STOF(ISTOF + 42) = Ea
      STOF(ISTOF + 43) = Vc
      STOF(ISTOF + 45) = Icr
      STOF(ISTOF + 46) = Iao
      STOF(ISTOF + 50) = P
      STOF(ISTOF + 51) = Idc
      STOF(ISTOF + 52) = dcVltg
      STOF(ISTOF + 62) = Igto1
      STOF(ISTOF + 63) = Vgto1
      STOF(ISTOF + 70) = Q
      STOF(ISTOF + 71) = Vrms
      STOF(ISTOF + 72) = Ibo
      STOF(ISTOF + 73) = Ico

! Array (1:3) quantities...
      DO IT_0 = 1,3
         STOF(ISTOF + 63 + IT_0) = I2(IT_0)
         STOF(ISTOF + 66 + IT_0) = E2(IT_0)
      END DO

!---------------------------------------
! Close Model Data read
!---------------------------------------

      IF ( TIMEZERO ) CALL EMTDC_CLOSEFILE
      RETURN
      END

!=======================================================================

      SUBROUTINE MainDyn_Begin()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------

!     SUBR    DQDyn_Begin   ! 
!     SUBR    abcDyn_Begin  ! 

!---------------------------------------
! Variable Declarations
!---------------------------------------


! Subroutine Arguments

! Electrical Node Indices

! Control Signals
      REAL     Iqref, RT_12, RT_13, RT_18

! Internal Variables

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER IT_0                                ! Storage Indices
      INTEGER ISUBS, SS(1), IBRCH(1), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------


! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      NCX       = NCX + 0
      INODE     = NNODE + 2
      NNODE     = NNODE + 24

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 1

      DO IT_0 = 1,1
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 57
!---------------------------------------
! Electrical Node Lookup
!---------------------------------------


!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 190:[const] Real Constant 

! 200:[time-sig] Output of Simulation Time 

! 310:[var] Variable Input Slider 'ref'

! 330:[sumjct] Summing/Differencing Junctions 

! 340:[pgb] Output Channel 'BRK1'

! 370:[DQ]  
      CALL DQDyn_Begin()


! 380:[const] Real Constant 

! 390:[sumjct] Summing/Differencing Junctions 

! 400:[pgb] Output Channel 'Iq'

! 410:[pi_ctlr] PI Controller \w Interpolation 
      RTCF(NRTCF) = 0.0
      NRTCF = NRTCF + 1

! 420:[const] Real Constant 

! 440:[pgb] Output Channel 'iqref'

! 450:[var] Variable Input Slider 'kp'

! 460:[signalgen] Signal Generator /w Interpolation 
      CALL COMPONENT_ID(ICALL_NO,802605095)
      CALL E_XSGEN1_CFG(1,180.0,50.0,1.0,-1.0)

! 470:[emtconst] Commonly Used Constants (pi...) 
      RT_18 = PI_

! 480:[gain] Gain Block 

! 490:[gain] Gain Block 

! 500:[var] Variable Input Slider 'I'

! 520:[compar] Two Input Comparator 

! 530:[DQ]  
      CALL DQDyn_Begin()


! 540:[bin_delay] Timed ON/OFF Logic Transition 

! 550:[mult] Multiplier 

! 560:[div] Divider 

! 570:[mult] Multiplier 

! 580:[pi_ctlr] PI Controller \w Interpolation 
      RTCF(NRTCF) = 0.0
      NRTCF = NRTCF + 1

! 590:[sumjct] Summing/Differencing Junctions 

! 600:[pi_ctlr] PI Controller \w Interpolation 
      RTCF(NRTCF) = 0.0
      NRTCF = NRTCF + 1

! 610:[sumjct] Summing/Differencing Junctions 

! 620:[sumjct] Summing/Differencing Junctions 

! 630:[abc]  
      CALL abcDyn_Begin()


! 640:[compar] Two Input Comparator 

! 650:[compar] Two Input Comparator 

! 660:[compar] Two Input Comparator 

! 670:[sumjct] Summing/Differencing Junctions 

! 680:[inv] Interpolated Logic Inverter 

! 690:[inv] Interpolated Logic Inverter 

! 700:[inv] Interpolated Logic Inverter 

! 710:[pgb] Output Channel 'pulse3'

! 720:[pgb] Output Channel 'Uq1'

! 730:[pgb] Output Channel 'pulse2'

! 740:[pgb] Output Channel 'Id'

! 750:[pgb] Output Channel 'triangle'

! 760:[pgb] Output Channel 'pulse1'

! 770:[pgb] Output Channel 'Ud1'

! 780:[pgb] Output Channel 'ref'

! 790:[pgb] Output Channel 'Uq'

! 800:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(1, 0,0.01, 1000000.0, 100000.0, 100000.0, 0.0, &
     &0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+45),SS(1),1,0,1,5000.0,0.0,0.05)

! 810:[pgb] Output Channel 'Ud'

! 820:[pgb] Output Channel 'GV'

! 830:[breaker1] Single Phase Breaker 'BRK1'
      CALL COMPONENT_ID(ICALL_NO,307025180)
      CALL E1PBRKR1_CFG(0.005,1000000.0,0.0)

! 840:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(3, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+12),SS(1),1,0,1,5000.0,0.0,0.05)

! 850:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(3, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+10),SS(1),1,0,1,5000.0,0.0,0.05)

! 860:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(3, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+8),SS(1),1,0,1,5000.0,0.0,0.05)

! 880:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(3, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+2),SS(1),1,0,1,5000.0,0.0,0.05)

! 900:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(3, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+4),SS(1),1,0,1,5000.0,0.0,0.05)

! 910:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(3, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+6),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+18),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+16),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+14),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[source_1] Single Phase Voltage Source Model 2 'Source1'
      CALL E_BRANCH_CFG( (IBRCH(1)+38),SS(1),1,0,0,0.3,0.0,0.0)
      CALL E_1PVSRC_CFG(0,0,1,0.75,60.0,0.0,0.3,0.0,0.0,0.0,0.0,0.05)

! 1:[source_3] Three Phase Voltage Source Model 2 'Source 2'
      RTCF(NRTCF)   = 0.38*SQRT_2*SQRT_1BY3
      RTCF(NRTCF+1) = 50.0*TWO_PI
      RTCF(NRTCF+3) = 0.0
      NRTCF = NRTCF + 4

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+20),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+22),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.005, 100000000.0, 100000.0, 100000.0, 0.&
     &0, 0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+24),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.01, 1000000.0, 100000.0, 100000.0, 0.0, &
     &0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+41),SS(1),1,0,1,5000.0,0.0,0.05)

! 1:[peswitch] Power electronic switch 
      CALL PESWITCH1_CFG(0, 0,0.01, 1000000.0, 100000.0, 100000.0, 0.0, &
     &0.0)
      CALL E_BRANCH_CFG( (IBRCH(1)+37),SS(1),1,0,1,5000.0,0.0,0.05)

      RETURN
      END

!=======================================================================

      SUBROUTINE MainOut_Begin()

!---------------------------------------
! Standard includes
!---------------------------------------

      INCLUDE 'nd.h'
      INCLUDE 'emtconst.h'
      INCLUDE 's0.h'
      INCLUDE 's1.h'
      INCLUDE 's4.h'
      INCLUDE 'branches.h'
      INCLUDE 'pscadv3.h'
      INCLUDE 'rtconfig.h'

!---------------------------------------
! Function/Subroutine Declarations
!---------------------------------------

!     SUBR    DQOut_Begin   ! 
!     SUBR    abcOut_Begin  ! 

!---------------------------------------
! Variable Declarations
!---------------------------------------


! Subroutine Arguments

! Electrical Node Indices
      INTEGER  NT_2, NT_3, NT_5(3), NT_8, NT_12
      INTEGER  NT_13, NT_28

! Control Signals

! Internal Variables
      INTEGER  IVD1_1

! Indexing variables
      INTEGER ICALL_NO                            ! Module call num
      INTEGER IT_0                                ! Storage Indices
      INTEGER ISUBS, SS(1), IBRCH(1), INODE       ! SS/Node/Branch/Xfmr


!---------------------------------------
! Local Indices
!---------------------------------------


! Increment and assign runtime configuration call indices

      ICALL_NO  = NCALL_NO
      NCALL_NO  = NCALL_NO + 1

! Increment global storage indices

      NCX       = NCX + 0
      INODE     = NNODE + 2
      NNODE     = NNODE + 24

! Initialize Subsystem Mapping

      ISUBS = NSUBS + 0
      NSUBS = NSUBS + 1

      DO IT_0 = 1,1
         SS(IT_0) = SUBS(ISUBS + IT_0)
      END DO

! Initialize Branch Mapping.

      IBRCH(1)     = NBRCH(SS(1))
      NBRCH(SS(1)) = NBRCH(SS(1)) + 57
!---------------------------------------
! Electrical Node Lookup
!---------------------------------------

      NT_2  = NODE(INODE + 2)
      NT_3  = NODE(INODE + 3)
      NT_8  = NODE(INODE + 10)
      NT_12 = NODE(INODE + 15)
      NT_13 = NODE(INODE + 16)
      NT_28 = NODE(INODE + 14)

! Array (1:3) quantities...
      DO IT_0 = 1,3
         NT_5(IT_0) = NODE(INODE + 4 + IT_0)
      END DO

!---------------------------------------
! Generated code from module definition
!---------------------------------------


! 100:[multimeter] Multimeter 
      IVD1_1 = NRTCF
      NRTCF  = NRTCF + 4
      IF (ABS(1.0) .GT. 1.0E-20) THEN
        RTCF(IVD1_1) = 1.0/ABS(1.0)
      ELSE
        RTCF(IVD1_1) = 1.0
      ENDIF
      IF (ABS(1.0) .GT. 1.0E-20) THEN
        RTCF(IVD1_1+1) = 1.0/ABS(1.0)
      ELSE
        RTCF(IVD1_1+1) = 1.0
      ENDIF
      RTCF(IVD1_1+2) = 0.02
      RTCF(IVD1_1+3) = 50.0

! 170:[pgb] Output Channel 'Vin'

! 180:[pgb] Output Channel 'Vin'

! 240:[pgb] Output Channel 'Ea'

! 250:[pgb] Output Channel 'Ic'

! 260:[pgb] Output Channel 'Vc'

! 270:[pgb] Output Channel 'Vap'

! 290:[pgb] Output Channel 'Vbp'

! 300:[tvekta] Phase-Locked Loop 
      CALL TVEKA1_CFG(1.0,50.0)

! 320:[pgb] Output Channel 'theta'

! 350:[pgb] Output Channel 'Vcp'

! 360:[pgb] Output Channel 'Iap'

! 370:[DQ]  
      CALL DQOut_Begin()


! 430:[pgb] Output Channel 'P'

! 510:[mult] Multiplier 

! 530:[DQ]  
      CALL DQOut_Begin()


! 630:[abc]  
      CALL abcOut_Begin()


! 870:[pgb] Output Channel 'Icr'

! 890:[pgb] Output Channel 'Vap'

! 920:[pgb] Output Channel 'Iagf'

! 930:[pgb] Output Channel 'Iap'

! 940:[pgb] Output Channel 'Iao'

! 950:[pgb] Output Channel 'Idc'

! 960:[pgb] Output Channel 'Pout'

! 970:[pgb] Output Channel 'dcVltg'

      RETURN
      END

